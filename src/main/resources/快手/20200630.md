# 第一面

## 一、技术

  1.1 Flink的序列化机制实现

  1.2 Flink Shuffle机制

  1.3 CMS和G1的垃圾收回机制的区别, CMS的五个阶段, G1的数据结构
    
    CMS垃圾回收器: https://www.jianshu.com/p/2a1b2f17d3e4
    
    G1垃圾回收器: https://cloud.tencent.com/developer/article/1459638

  1.4 垃圾回收线程触发时机(线程安全点)
  
    安全点, 即程序执行时并非在所有地方都能停顿下来开始GC, 只有在到达安全点时才能暂停, 这是因为HotSpot虚拟机采取的是可达性分析算法, 通过GC Roots判定回收的对象. 
    
    安全点的初始目的并不是让其他线程停下, 而是找到一个稳定的执行状态, 在这种状态下Java虚拟机栈不会发生变化, 垃圾回收器可"安全"的进行可达性分析.
    
    JVM在GC之前需要等待所有的应用线程进入到安全点, 若某个线程没有进入安全点, 就会导致GC时JVM停顿时间延长.
  
    安全点位置选择: 循环的末尾, 方法临返回前, 调用方法之后, 抛异常的位置
    
    JVM如何保证所有线程都运行到最近的Safe Point上停下来(有两种方式):
    
      抢断式中断: GC发生时, 首先中断所有线程, 如果发现线程未执行到Safe Point, 就恢复线程让其运行到Safe Point
      
      主动式中断: GC发生时, 不直接操作线程中断而设置一个标志, 让各个线程执行时主动轮询这个标志, 发现中断标志为真时就自己中断挂起
      
    JVM采取的是主动式中断, 轮询标志的地方和安全点是重合的. 对于主动式中断需要线程轮询标记位, 那么对于"休眠"状态的线程怎么中断:
      
      JVM引入安全区域(Safe Region), 所谓安全区域是指在一段代码片段中的引用关系不会发生变化. 
      
      线程在进入安全区域时先标记进入SafeRegion, 等到被唤醒时准备离开Safe Region时, 先检查能否离开, 若GC完成则可以离开, 否则必须等待直到收到安全离开的信号为止
      
    LINK: https://www.cnblogs.com/xuanyuan/p/12467264.html  
    
  1.5 JVM内存分配担保机制

    JVM使用分代算法, 将堆内存分为年轻代和老年代, 两块内存采用不同的垃圾回收算法, 空间担保是指老年代进行空间分配担保.
  
    发生Minor GC前, 虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间: 
  
    若是大于, 则此次Minor GC是安全的
  
    若是小于, 则查看虚拟机是否允许担保失败(JDK1.6后默认开启), 若是允许担保失败, 则会检查检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小 
    
      若是大于, 则尝试进行一次Minor GC, 但此次的Minor GC依然有风险
    
      若是小于或者不允许空间分配担保, 则进行一次Full GC
  
    NOTE: 
  
    JVM内存分配担保机制为什么需要的是连续的内存空间
  
      新生代的复制算法机制决定了需要连续空间(对象的分配的空间是连续的), 因为分配担保机制担保成功, 对象直接复制最快速. 
    
      JVM的对象分配和回收是非常高频的事情, 若在老年代零碎的空间中寻找能放得下的空间, 将是非常繁琐耗时的事情, 这在效率上是不允许的.
  
    JVM内存分配担保机制的存在的意义
    
      分配担保最关键的是: 发生Minor GC前是否需要根据历届晋升到老年代的平均值来发起一次Full GC, 换句话来说, 去掉分配担保就意味着Full GC发生的几率更大
  
  1.6 一致性协议(Raft的原理)

  1.7 脑裂问题解决方案


## 二、算法

  2.1 给定数组的全排列(实现参见: RM0001)  